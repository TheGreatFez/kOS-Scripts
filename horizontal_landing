//WARNING COMPATIBILITY CHECK
//-This script is only ment to work on non-atmosphere bodies, have not tested or run this on atmosphere bodies.
//-Only works if the ship does not have to stage in the middle of the landing burn. Otherwise all calculations might be thrown off
//-Only works if the ship is at near 0 starting inclination and very circular

// Execute Node Function
declare function ExecuteNode {
	clearscreen.
	lock throttle to 0.
	SAS off.
	lock DeltaV to nextnode:deltav:mag.
	set BurnTime to .5*DeltaV*mass/availablethrust.
	lock steering to nextnode.
	print "Aligning with Maneuver Node".
	until VANG(ship:facing:vector,nextnode:burnvector) < 1 {
		print "Direction Angle Error = " + round(VANG(ship:facing:vector,nextnode:burnvector),1) + "   "at(0,1).
	}
	clearscreen.
	print "Warping to Node".
	print "Burn Starts at T-minus " + round(BurnTime,2) + "secs   ".
	warpto(time:seconds + nextnode:eta - BurnTime - 10).
	wait until BurnTime >= nextnode:eta.
	
	clearscreen.
	lock throttle to DeltaV*mass/availablethrust.
	print "Executing Node".
	
	until DeltaV <= .1 {
		print "Delta V = " + round(DeltaV,1) + "   " at(0,1).
		print "Throttle = " + MIN(100,round(throttle*100)) + "%   " at(0,2).
	}
	lock throttle to 0.
	unlock all.
	remove nextnode.
	clearscreen.
	print "Node Executed".
}

// Landing position
CLEARVECDRAWS().
SAS OFF.
lock steering to srfretrograde.
set landing_pos to LATLNG(0,90).
set buffer_dist to 10.
set buffer_speed_h to 0.
set landing_per_buffer to 500.
set landing_eta_buffer to 50.
set CutOffThrottle to .75.
set MaxCount to 3.

lock R_ship to ship:body:position.
lock angle_diff_h to VANG(-R_ship, landing_pos:position - R_ship).
lock dist_diff_h to (angle_diff_h/360)*2*(constant:pi)*R_ship:mag.
lock Velocity_h_norm to VCRS(VCRS(R_ship,ship:velocity:orbit),R_ship):normalized.
lock Speed_h to VDOT(Velocity_h_norm,ship:velocity:orbit).
lock speed_diff_h to Speed_h-landing_pos:altitudevelocity(altitude):orbit:mag.
clearscreen.

set prev_dist_h to dist_diff_h.
wait .1.
set curr_dist_h to dist_diff_h.
set delta_dist_h to curr_dist_h - prev_dist_h. 

if delta_dist_h > 0 {
	set eta_node to ((constant:pi)*R_ship:mag-dist_diff_h)/speed_diff_h.
	if eta_node < 60 {
		set eta_node to ((constant:pi)*R_ship:mag-dist_diff_h+(constant:pi)*R_ship:mag)/speed_diff_h.
		}
} else {
	set eta_node to ((constant:pi)*R_ship:mag+dist_diff_h)/speed_diff_h.
	}
set R_per_landing to ship:body:radius + landing_pos:terrainheight + landing_per_buffer.
set SMA_landing to (R_ship:mag + R_per_landing)/2.
set ecc_landing to (R_ship:mag - R_per_landing)/(R_ship:mag + R_per_landing).
set V_apo to sqrt(((1-ecc_landing)*ship:body:MU)/((1+ecc_landing)*SMA_landing)).
set deltaV_landing to V_apo - velocityat(ship,time:seconds + eta_node):orbit:mag.
for node in allnodes {remove node.}
set landing_node to NODE(TIME:seconds + eta_node, 0, 0, deltaV_landing).
ADD landing_node.

ExecuteNode().
// I have no idea why I have to retype all the variables I defined earlier but if I don't it gives me some strange errors that the variables aren't defined.
// If anyone would like to help, you can comment from the next line to the "End of the commenting section" and try and run it. I hope you get the same error, and know how to fix it!
lock steering to srfretrograde.
set landing_pos to LATLNG(0,90).
set buffer_dist to 0.
set buffer_speed_h to 0.
set landing_per_buffer to 500.
set landing_eta_buffer to 50.
set CutOffThrottle to 0.
set MaxCount to 5.

lock R_ship to ship:body:position.
lock angle_diff_h to VANG(-R_ship, landing_pos:position - R_ship).
lock dist_diff_h to (angle_diff_h/360)*2*(constant:pi)*R_ship:mag.
lock Velocity_h_norm to VCRS(VCRS(R_ship,ship:velocity:orbit),R_ship):normalized.
lock Speed_h to VDOT(Velocity_h_norm,ship:velocity:orbit).
lock speed_diff_h to Speed_h-landing_pos:altitudevelocity(altitude):orbit:mag.
clearscreen.
// End of commenting section.
lock MaxThrustAccHor to -1*VDOT(Velocity_h_norm,availablethrust/mass*srfretrograde:vector).
lock Vmax_h to sqrt(MAX(0,2*(dist_diff_h-buffer_dist)*MaxThrustAccHor) + buffer_speed_h^2).

lock error_h to Vmax_h - speed_diff_h.
set errorP_h to 0.
set Kp_h to 0.07.
set errorD_h to 0.
set Kd_h to 0.04.
set ThrustSet to 0.
lock throttle to ThrustSet.
set time0 to time:seconds.
lock time1 to time:seconds - time0.
set count to 1.
set flightmode to 1.

set align_vector to -1*landing_pos:altitudevelocity(altitude):orbit.
lock steering to align_vector.
print "Aligning with Surface Retrograde Preemptively".
until VANG(ship:facing:vector,align_vector) < 1 {
	print "Direction Angle Error = " + round(VANG(ship:facing:vector,align_vector),1) + "   "at(0,1).
}
clearscreen.
print "Warping to " + round(landing_eta_buffer,0) + "sec before Periapsis".
warpto(time:seconds + eta:periapsis - landing_eta_buffer).
lock steering to srfretrograde.
clearscreen.
until flightmode = 2 {
	set LandingVector to VECDRAW(landing_pos:position,(altitude-landing_pos:terrainheight+25)*(landing_pos:position-R_ship):normalized,GREEN,"Landing Position",1.0,TRUE,.5).
	if flightmode = 1 {
	
		set error1_h to error_h.
		set t1 to time1.
		wait .00001.
		set error2_h to error_h.
		set t2 to time1.
		set dt to t2-t1.
		// I like to take an average error so its not going crazy due to discrete calculations.
		set errorP_h to .5*(error1_h+error2_h).
		set errorD_h_test to (error2_h-error1_h)/dt.
		//This next part is used as a running average, the Derivative term was behaving eratically thus this damps out the spikes.
		if count < MaxCount {
			if count < 2 {
				set errorD_h to errorD_h_test.
				}
			if count >= 2 {
				set errorD_h to (errorD_h*(count-1)+errorD_h_test)/count.
				}
			set count to count + 1.		
			}
		if count >= MaxCount {
		
			set errorD_h to (errorD_h*(MaxCount-1)+errorD_h_test)/MaxCount.
			}
		
		set ThrustSet to 1 - Kp_h*errorP_h - Kd_h*errorD_h.
		
		if ThrustSet > 1 {
			set ThrustSet to 1.
			}
		if ThrustSet < CutOffThrottle {
			set ThrustSet to 0.
			}
		if errorP_h < 0 {
			set ThrustSet to 1. // This is very important. If the error ever drops below 0, it means it might crash since the
								// equation is calculated based on full thrust. 
			}
		if speed_diff_h < 1 {
			set ThrustSet to 0.
			set flightmode to 2.
			}
		if (dist_diff_h < (buffer_dist + 1)) AND speed_diff_h < 2.5 {
			set ThrustSet to 0.
			set flightmode to 2.
			}
	}
	
	print "Horizontal Distance to Landing Site = " + round(dist_diff_h,2) + "     "at (0,0).
	print "Speed relative to Landing Site = " + round(speed_diff_h,2) at (0,1).
	print "MaxThrustAccHor = " + round(MaxThrustAccHor,2) at (0,2).
	print "Vmax_h = " + round(Vmax_h,2) at (0,3).
	print "errorP_h = " + round(errorP_h,2) at (0,4).
	print "errorD_h = " + round(errorD_h,2) at (0,5).
	print "ThrustSet = " + round(ThrustSet*100,2) + "%     " at (0,6).
	print "Flightmode = " + flightmode at (0,7).
	}
	run vertical_landing(landing_pos).